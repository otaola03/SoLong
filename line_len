./srcs/ft_check_map.c:17:	if (i == 0 && !(mem->map[i][j] == '1' || mem->map[i][j] == '\n'))
./srcs/ft_check_map.c:19:	else if (i == (mem->map_len) &&  !(mem->map[i][j] == '1' || mem->map[i][j] == '\n'))
./srcs/ft_check_map.c:21:	else if ((j == 0 || j == line_len - 2) && mem->map[i][j] != '1')
./srcs/ft_check_map.c:23:	else if (!(mem->map[i][j] == '0' || mem->map[i][j] == '1' || mem->map[i][j] == 'C' || mem->map[i][j] == 'E' || mem->map[i][j] == 'P' || mem->map[i][j] == '\n'))
./srcs/ft_check_map.c:30:	if (mem->map[i][j] == 'C')
./srcs/ft_check_map.c:31:		mem->collect++;
./srcs/ft_check_map.c:32:	else if (mem->map[i][j] == 'E')
./srcs/ft_check_map.c:33:		mem->exit++;
./srcs/ft_check_map.c:34:	else if (mem->map[i][j] == 'P')
./srcs/ft_check_map.c:36:		mem->p_pos[0] = i;
./srcs/ft_check_map.c:37:		mem->p_pos[1] = j;
./srcs/ft_check_map.c:38:		mem->entry++;
./srcs/ft_check_map.c:48:	mem->exit = 0;
./srcs/ft_check_map.c:49:	mem->entry = 0;
./srcs/ft_check_map.c:50:	mem->collect = 0;
./srcs/ft_check_map.c:51:	line_len = ft_strlen(mem->map[0]);
./srcs/ft_check_map.c:53:	while (mem->map[++i])
./srcs/ft_check_map.c:56:		while (mem->map[i][++j])
./srcs/ft_check_map.c:65:	if (mem->collect == 0 || mem->exit != 1 || mem->entry != 1)
./srcs/ft_check_path.c:31:	if (!ft_check_pos(i - 1, j, mem->map))
./srcs/ft_check_path.c:33:	else if (!ft_check_pos(i, j + 1, mem->map))
./srcs/ft_check_path.c:35:	else if (!ft_check_pos(i + 1, j, mem->map))
./srcs/ft_check_path.c:37:	else if (!ft_check_pos(i, j - 1, mem->map))
./srcs/ft_check_path.c:45:	if (mem->map[neighbour->i][neighbour->j] == 'C')
./srcs/ft_check_path.c:47:		mem->c_pos[*collect * 2] = neighbour->i;
./srcs/ft_check_path.c:48:		mem->c_pos[(*collect * 2) + 1] = neighbour->j;
./srcs/ft_check_path.c:53:		mem->e_pos[0] = neighbour->i;
./srcs/ft_check_path.c:54:		mem->e_pos[1] = neighbour->j;
./srcs/ft_check_path.c:70:			if (mem->map[neighbour->i][neighbour->j] == 'C' || mem->map[neighbour->i][neighbour->j] == 'E')
./srcs/ft_check_path.c:73:				mem->map[neighbour->i][neighbour->j] += ('a' - 'A');
./srcs/ft_check_path.c:77:				mem->map[neighbour->i][neighbour->j] = '2';
./srcs/ft_check_path.c:90:	mem->c_pos = (int *)malloc(sizeof(int) * mem->collect * 2);
./srcs/ft_check_path.c:95:	while (queue->first && cont < mem->collect + 1)
./srcs/ft_check_path.c:103:	if (cont == mem->collect + 1)
./srcs/ft_general_free.c:28:	ft_free_2d_arr(mem->map);
./srcs/ft_general_free.c:35:	ft_free_2d_arr(mem->map);
./srcs/ft_general_free.c:36:	free(mem->c_pos);
./srcs/ft_general_free.c:38:		ft_end_game(mem->game);
./srcs/ft_key_hook.c:17:	if (mem->map[i][j] == 'c')
./srcs/ft_key_hook.c:19:		mem->map[i][j] = '2';
./srcs/ft_key_hook.c:20:		mem->game->cont++;
./srcs/ft_key_hook.c:21:		if (mem->game->cont == mem->collect)
./srcs/ft_key_hook.c:22:			mem->game->exit = 1;
./srcs/ft_key_hook.c:25:	else if (mem->map[i][j] == 'e' && mem->game->exit != 1)
./srcs/ft_key_hook.c:27:	else if (mem->map[i][j] == 'e' && mem->game->exit == 1)
./srcs/ft_key_hook.c:29:		//ft_end_game(mem->game);
./srcs/ft_key_hook.c:38:	mlx_put_image_to_window(mem->game->mlx, mem->game->win, mem->game->imgs[0],\
./srcs/ft_key_hook.c:39:		mem->p_pos[1] * 32, mem->p_pos[0] * 32);
./srcs/ft_key_hook.c:40:	if (mem->map[mem->p_pos[0]][mem->p_pos[1]] == 'e')
./srcs/ft_key_hook.c:41:		mlx_put_image_to_window(mem->game->mlx, mem->game->win, mem->game->imgs[3],\
./srcs/ft_key_hook.c:42:			mem->p_pos[1] * 32, mem->p_pos[0] * 32);
./srcs/ft_key_hook.c:44:		mlx_put_image_to_window(mem->game->mlx, mem->game->win, mem->game->imgs[0], j * 32, i * 32);
./srcs/ft_key_hook.c:46:		mlx_put_image_to_window(mem->game->mlx, mem->game->win, mem->game->imgs[3], j * 32, i * 32);
./srcs/ft_key_hook.c:47:	mlx_put_image_to_window(mem->game->mlx, mem->game->win, mem->game->imgs[k], j * 32, i * 32);
./srcs/ft_key_hook.c:48:	mem->p_pos[0] = i;
./srcs/ft_key_hook.c:49:	mem->p_pos[1] = j;
./srcs/ft_key_hook.c:50:	mem->game->movements++;
./srcs/ft_key_hook.c:51:	ft_putnbr(mem->game->movements);
./srcs/ft_key_hook.c:60:	if (keycode == 0 && mem->map[mem->p_pos[0]][mem->p_pos[1] - 1] != '1')
./srcs/ft_key_hook.c:61:		ft_move(mem, mem->p_pos[0], mem->p_pos[1] - 1, 5);
./srcs/ft_key_hook.c:62:	else if (keycode == 2 && mem->map[mem->p_pos[0]][mem->p_pos[1] + 1] != '1')
./srcs/ft_key_hook.c:63:		ft_move(mem, mem->p_pos[0], mem->p_pos[1] + 1, 4);
./srcs/ft_key_hook.c:64:	else if (keycode == 13 && mem->map[mem->p_pos[0] - 1][mem->p_pos[1]] != '1')
./srcs/ft_key_hook.c:65:		ft_move(mem, mem->p_pos[0] - 1, mem->p_pos[1], 6);
./srcs/ft_key_hook.c:66:	else if (keycode == 1 && mem->map[mem->p_pos[0] + 1][mem->p_pos[1]] != '1')
./srcs/ft_key_hook.c:67:		ft_move(mem, mem->p_pos[0] + 1, mem->p_pos[1], 7);
./srcs/ft_key_hook.c:70://		ft_end_game(mem->game);
./srcs/ft_new.c:33:	width = ft_strlen(mem->map[0]) - 1;
./srcs/ft_new.c:34:	mem->game = (t_game *)malloc(sizeof(t_game));
./srcs/ft_new.c:35:	ft_new_game(mem->game);
./srcs/ft_new.c:36:	ft_new_window(mem->game, width *  32, mem->map_len * 32);
./srcs/ft_new.c:37:	mem->game->cont = 0;
./srcs/ft_new.c:38:	mem->game->exit = 0;
./srcs/ft_new.c:39:	mem->game->movements = 0;
./srcs/ft_save_map.c:47:	mem->map_len = ft_cont_lines(map_addr);
./srcs/ft_save_map.c:48:	printf("map_len: %d\n", mem->map_len);
./srcs/ft_save_map.c:49:	mem->map = (char **)malloc(sizeof(char *) * (mem->map_len + 1));
./srcs/ft_save_map.c:50:	if (!mem->map)
./srcs/ft_save_map.c:55:	mem->map[i++] = str;
./srcs/ft_save_map.c:59:		mem->map[i++] = str;
./srcs/ft_save_map.c:62:	mem->map[i] = NULL;
./srcs/main.c:25:	printf("path: %d\n", ft_check_path(mem, mem->p_pos[0], mem->p_pos[1]));
./srcs/main.c:27:	if (ft_check_map(mem) || ft_check_path(mem, mem->p_pos[0], mem->p_pos[1]))
./srcs/main.c:33:	ft_set_images(mem->game, mem->map);
./srcs/main.c:34:	mlx_key_hook(mem->game->win, ft_key_hook, mem);
./srcs/main.c:35:	mlx_hook(mem->game->win, 17, 1L << 17, ft_press_x, mem);
./srcs/main.c:36:	mlx_loop(mem->game->mlx);
